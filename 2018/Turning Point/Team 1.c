#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    powerExpanderBatterySensor, sensorAnalog)
#pragma config(Sensor, dgtl12, claw,           sensorDigitalOut)
#pragma config(Sensor, I2C_1,  driveRIme,      sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  armLIme,        sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  driveLIme,      sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           driveMR,       tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port2,           driveBR,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           armR,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           intake,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           driveMBL,      tmotorVex393_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port6,           launcher,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           driveFL,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           driveFR,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           armL,          tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

// TODO: limit to legal height under some conditions
// TODO: Buttons to get to max height/high post and mid post
// TODO: Button to reset arm IME to zero. Cortex?
// TODO: 36 inch max expansion in any horizontal dimension.

/*
To reduce the maximum current for each circuit breaker (ports 1-5, 6-10, power expander), we have tried to spread the load equally. Thus, each breaker only has two drive motors as they will be used extensively, and the load for the arm is spread out across two breaker.

Port 10 is unusable in the Cortex due to previous events, and as 10 motors are needed, a Y-cable is instead used.

http://markdowntable.com/

For motor naming, look at the robot from above with the cap flipper pointing upwards

| Port | Motor Description                    | Name     | Slave Motor    | Power Expander | IME              | Gearing | Reversed |
|------|--------------------------------------|----------|----------------|----------------|------------------|---------|----------|
| 1    | Middle Right Drive                   | driveMR  | Master         | No             | Yes - 1          | Torque  | Yes      |
| 2    | Back Right Drive                     | driveBR  | Yes - driveMR  | No             | No               | Torque  | Yes      |
| 3    | Arm Right                            | armR     | Yes - armL     | No             | No               | Unknown | No       |
| 4    | Intake                               | intake   | No             | Yes - A        | No               | Torque  | Yes      |
| 5    | Back and Middle Left Drive (Y-Cable) | driveMBL | Master         | Yes - B        | Yes (Middle) - 3 | Torque  | No       |
| 6    | Launcher                             | launcher | No             | Yes - C        | No               | Unknown | Yes      |
| 7    | Front Left Drive                     | driveFL  | Yes - driveMBL | No             | No               | Torque  | No       |
| 8    | Front Right Drive                    | driveFR  | Yes - driveMR  | No             | No               | Torque  | Yes      |
| 9    | Arm Left                             | armL     | Master         | No             | Yes - 3          | Unknown | Yes      |


## Controls
### Drive
During tank drive: left, right joysticks' vertical axis used (Ch3, Ch2)
During arcade drive: left joystick's vertical and right joystick's horizontal (Ch3, Ch1)
*/


// ## Global Variables
// ### Button Constants and related functions
// This stops the button from being updated only in one place
const short BTN_TRIGGER_PNEUMATICS = Btn8D;
const short BTN_DRAW_LAUNCHER_BACK = Btn7D;

const short BTN_LOWER_ARM = Btn5D;
const short BTN_RAISE_ARM = Btn5U;
// NB: BTN_LOWER_ARM and BTN_RAISE_ARM at the same time causes it to rise slowly
const short BTN_TOGGLE_LOCK_ARM_PID = Btn6D;
const short BTN_TOGGLE_POST_ARM_PID = Btn8L;

const short BTN_TOGGLE_DRIVE_MODE = Btn8U;

const short BTN_INTAKE_IN = Btn6U;
const short BTN_INTAKE_OUT = Btn7R;

bool btnComboAutonomous() { return vexRT[Btn7L] && vexRT[Btn8R]; } // Triggers autonomous. Needed when there is no field control.
bool btnComboRaiseArmSlowly() { return vexRT[BTN_LOWER_ARM] && vexRT[BTN_RAISE_ARM]; } // Raises arm slowly

// ## For PID
const float COUNTS_PER_MOTOR_ROTATION[] = {627.2, 392, 261.333 }; // Number of counts for one rotation of the motor
enum gearingTypes { TORQUE, HIGHSPEED, TURBO }; // Enum corresponding to the array above

// ### System
const int MAIN_LOOP_DELAY = 10;

// ### Drive
bool driveIsTank = true;
bool driveWasPressed = false;

const float WHEEL_RADIUS_INCHES = 2;
const float METERS_PER_WHEEL_ROTATION = 2 * PI * WHEEL_RADIUS_INCHES * 0.0254; //0.0254 to convert inches to meters
const short DRIVE_MOTORS_GEARING = TORQUE; // Drive using torque motors. Declared as short instead of `enum gearingTypes varName` as I want to use it as an index

// ### Drive Pid
// #### Left
bool driveLErrorPositive = false;
long driveLError = 0;
long driveLIntegral = 0;
const long DRIVE_L_MAX_VALUE = 30000;
long driveLTarget = 0;

// #### Right
bool driveRErrorPositive = false;
long driveRError = 0;
long driveRIntegral = 0;
const long DRIVE_R_MAX_VALUE = 30000;
long driveRTarget = 0;

// ### Intake
const int INTAKE_SPEED = 100;

// ### Claw
bool clawWasPressed = false;

// ### Arm
const int ARM_SPEED = 127;
const int ARM_SLOW_SPEED = 50;

// #### Arm IME
// 0 = very bottom
const int ARM_MAX_HEIGHT = 1300; // Max ~1370, but momentum so make it a bit lower
const int ARM_HIGH_POST_HEIGHT = 1224;
const int ARM_LOW_POST_HEIGHT = 500; //TODO NOT ACTUALLY TESTED
void resetArmImeZeroPoint() {
	if (nLCDButtons == 1) resetMotorEncoder(armL); // reset if LCD LEFT BUTTON pressed (2=center,4=right)
}


// #### Arm PID
enum armPidStateEnum { ARM_PID_DISABLED, ARM_PID_LOCKED, ARM_PID_LOW_POST, ARM_PID_HIGH_POST };
enum armPidStateEnum armPidState = ARM_PID_DISABLED; // initial state

long armError = 0;
long armIntegral = 0;
const long ARM_INTEGRAL_MAX_VALUE = 30000;
long armTarget = 0;

bool armPidLockFirstTimePressed = true; // Button toggling free/lock at current height
bool armPidPostFirstTimePressed = true; // Button toggling going to low/high post



// ## Launcher
const int LAUNCHER_SPEED = 100;



float distanceToDriveTicks(float distance, short gearingType) {
	return distance / METERS_PER_WHEEL_ROTATION * COUNTS_PER_MOTOR_ROTATION[gearingType];
}



task BatteryVoltageLCD() {
	string line;
	float primary;
	float secondary;
	while (true) {
		wait1Msec(1000); // Updates every second
		clearLCDLine(0); // clear top line

		primary = nImmediateBatteryLevel / 1000.0;
		secondary = SensorValue[powerExpanderBatterySensor] / 180.0; // Vex forums say 270.0, but differs between cortex and power expander. 1.4-1.6 seems to be around the difference multiplier
		sprintf(line, "1: %.1fV; 2: %.1fV", primary, secondary);
		displayLCDString(0, 0, line);
	}
	// endTimeSlice() needed if there is no wait

}


void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks
  // running between Autonomous and Driver controlled modes. You will need to
  // manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;
	slaveMotor(armR, armL);

	slaveMotor(driveBR, driveMR);
	slaveMotor(driveFR, driveMR);

	slaveMotor(driveFL, driveMBL);

  resetMotorEncoder(armL); // Otherwise, this returns 0. Very fustrating
  resetMotorEncoder(driveMBL);
  resetMotorEncoder(armR);

  bLCDBacklight = true; // Turn on backlight

  startTask(BatteryVoltageLCD);
  
	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	// bDisplayCompetitionStatusOnLcd = false;

  // All activities that occur before the competition starts
  // Example: clearing encoders, setting servo positions, ...

}


void drive(int l, int r) {
	motor[driveMBL] = l;
	motor[driveMR] = r;
}

void driveTank() { drive(vexRT[Ch3], vexRT[Ch2]); }
void driveArcade() { drive(vexRT[Ch3] + vexRT[Ch1], vexRT[Ch3] - vexRT[Ch1]); }



void arm(int speed) { motor[armL] = speed; }


int armPid(int target, long currentArmImeValue, bool reset) {
	const float kP = 0.7;
	const float kI = 0.01;
	const float kD = 0.1;

	if (reset) armError = armIntegral = 0;

	long error = target - currentArmImeValue;

	armIntegral += error;

	if (armIntegral > ARM_INTEGRAL_MAX_VALUE) armIntegral = ARM_INTEGRAL_MAX_VALUE;
	else if (armIntegral < -ARM_INTEGRAL_MAX_VALUE) armIntegral = -ARM_INTEGRAL_MAX_VALUE;

	int armDerivative = error - armError;
	armError = error; // Update error

	int power = armError * kP + armIntegral * kI + armDerivative * kD;

	// writeDebugStreamLine("Motor: %d Sensor: %d Error: %d dt: %d Integral %d", power, error + target, error, armDerivative, armIntegral);

	if (power > 127) power = 127;
	else if (power < -127) power = 127;
	return power;
}


// turns out, RobotC doesn't have pointers so I can't make any generic function for the two sides
// riveL => riveR, MBL => MR
int driveLPid(int distance, int maxSpeed, bool reset) {
	const float kP = 0.7;
	const float kI = 0.01;
	const float kD = 0.1;

	long target = distanceToDriveTicks(distance, DRIVE_MOTORS_GEARING);

	if (reset) {
		driveLError = driveLIntegral = 0; // Reset some values
		resetMotorEncoder(driveMBL);
		driveLErrorPositive = true; // Zero is positive
	}

	long currentDriveLImeValue = nMotorEncoder(driveMBL);

	long error = target - currentDriveLImeValue;

	driveLIntegral += error;

	if (currentDriveLImeValue > 0 && !driveLErrorPositive || currentDriveLImeValue < 0 && driveLErrorPositive) driveLIntegral = 0; //If errors have different signs, then passed the target. Thus, set integral to zero;

	driveLErrorPositive = currentDriveLImeValue > 0;


	if (driveLIntegral > DRIVE_L_MAX_VALUE) driveLIntegral = DRIVE_L_MAX_VALUE;
	else if (driveLIntegral < -DRIVE_L_MAX_VALUE) driveLIntegral = -DRIVE_L_MAX_VALUE;

	int driveLDerivative = error - driveLError;
	driveLError = error; // Update error

	int power = driveLError * kP + driveLIntegral * kI + driveLDerivative * kD;

	if (power > maxSpeed) power = maxSpeed;
	if (power < -maxSpeed) power = -maxSpeed;

	// writeDebugStreamLine("Motor: %d Sensor: %d Error: %d dt: %d Integral %d", power, error + target, error, driveLDerivative, driveLIntegral);

	return power;
}




void auto() {
	motor[launcher] = LAUNCHER_SPEED;
	wait1Msec(3500);
	motor[launcher] = 0;

}

task autonomous()
{
	auto();
}





task usercontrol()
{
	// auto();
  	// setMotorTarget(armL, 500, 100, true);

	int maxSpeed = 40;
	// int l = driveLPid(1, maxSpeed, true);
	// int r = driveRPid(1, maxSpeed, true);

	// drive(l, r);



	string lcdLineTwo;

	while (true)
	{
		// ### Random
		wait1Msec(MAIN_LOOP_DELAY);

		clearLCDLine(1);
		sprintf(lcdLineTwo, "Arm: %d", nMotorEncoder(armL));
		displayLCDString(1, 0, lcdLineTwo);

		if (btnComboAutonomous()) auto(); // For when there is no field control. Start auto with 7L and 8R

		// int l = driveLPid(1, maxSpeed, false);
		// int r = driveRPid(1, maxSpeed, false);
		// drive(l, r);

		// armPid(1000, nMotorEncoder(armL), false); // Change the value of the number

		// ### Drive
		if (vexRT[BTN_TOGGLE_DRIVE_MODE] && !driveWasPressed) {
			driveIsTank = !driveIsTank;
			driveWasPressed = true;
		}
		else driveWasPressed = false;

		if (driveIsTank) driveTank();
		else driveArcade();


		// ### Arm
		resetArmImeZeroPoint();

		long armImeValue = nMotorEncoder(armL);
		bool reset = false;

		if (vexRT[BTN_TOGGLE_LOCK_ARM_PID]) { // Press to toggle arm IME state
			if (armPidLockFirstTimePressed) {
				// Setup
				if (armPidState != ARM_PID_LOCKED) armPidState = ARM_PID_LOCKED; // Enable if not currently in lock
				else armPidState = ARM_PID_DISABLED; // Disable if currently locked

				armTarget = ARM_HIGH_POST_HEIGHT; // Set the new target
				reset = true; // Must reset PID control since it was freshly pressed
			}
			armPidLockFirstTimePressed = false; // Ensure setup only runs once per button press
		} else armPidLockFirstTimePressed = true; // If not pressed, the next time it is pressed the initialization will run

		if (vexRT[BTN_TOGGLE_POST_ARM_PID]) {
			if (armPidPostFirstTimePressed) {
				if (armPidState == ARM_PID_LOW_POST) {
					armPidState = ARM_PID_HIGH_POST; // If currently low, go to high
					armTarget = ARM_HIGH_POST_HEIGHT;
				}
				else {
					armPidState = ARM_PID_LOW_POST; // Otherwise, go to low
					armTarget = ARM_LOW_POST_HEIGHT;
				}
				reset = true;
			}
			armPidPostFirstTimePressed = false;
		} else armPidPostFirstTimePressed = true;


		if (vexRT[BTN_RAISE_ARM] || vexRT[BTN_LOWER_ARM]) armPidState = ARM_PID_DISABLED; // If either of the arm buttons are pressed, disable Pid

		int power;
		if (armPidState != ARM_PID_DISABLED) { // If enabled, call the PID function
			power = armPid(armTarget, armImeValue, reset);
		}
		else {
			if (vexRT[BTN_RAISE_ARM] && vexRT[BTN_LOWER_ARM]) power = ARM_SLOW_SPEED; //If both buttons pressed go up slowly
			else if (vexRT[BTN_LOWER_ARM]) power = -ARM_SPEED;
			else if (vexRT[BTN_RAISE_ARM]) power = ARM_SPEED;
			else power = 0;
		}


		if (armImeValue > ARM_MAX_HEIGHT && power > 0) power = 0; // If going up and arm value greater than maximum, disable it
		// TODO? Limit bottom as well?
		arm(power);




    // ### Intake
		motor[intake] = (vexRT[BTN_INTAKE_IN] - vexRT[BTN_INTAKE_OUT]) * INTAKE_SPEED;

		// ### Pneumatics
		if (vexRT[BTN_TRIGGER_PNEUMATICS] && !clawWasPressed) { // Only runs once after button pressed
			SensorValue[claw] = !SensorValue[claw]; //Switch value of claw
		}
		clawWasPressed = vexRT[BTN_TRIGGER_PNEUMATICS];

		// ### Launcher
  	motor[launcher] = (vexRT[BTN_DRAW_LAUNCHER_BACK] - vexRT[Btn7U]) * LAUNCHER_SPEED; // Draw the launcher back // TEMP TODOD!!!!!!!!!!!!!!!!!
  }
}
