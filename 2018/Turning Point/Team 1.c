#pragma config(Sensor, dgtl12, claw,           sensorDigitalOut)
#pragma config(Sensor, I2C_1,  armIME,         sensorNone)
#pragma config(Motor,  port1,           driveMR,       tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           driveBR,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           armR,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           intake,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           driveMBL,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           launcher,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           driveFL,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           driveFR,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           armL,          tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
To reduce the maximum current for each circuit breaker (ports 1-5, 6-10, power expander), we have tried to spread the load equally. Thus, each breaker only has two drive motors as they will be used extensively, and the load for the arm is spread out across two breaker.

Port 10 is unusable in the Cortex due to previous use, and as 10 motors are needed, a Y-cable is instead used.

// http://markdowntable.com/


| Port | Motor Description                    | Name     | Slave Motor    | Power Expander | IME          | Gearing | Reversed |
|------|--------------------------------------|----------|----------------|----------------|--------------|---------|----------|
| 1    | Middle Right Drive                   | driveMR  | Master         | No             | Yes          | Torque  | Yes      |
| 2    | Back Right Drive                     | driveBR  | Yes - driveMR  | No             | No           | Torque  | Yes      |
| 3    | Arm Right                            | armR     | Yes - armL     | No             | No           | Unknown | No       |
| 4    | Intake                               | intake   | No             | Yes - A        | No           | Unknown | No       |
| 5    | Back and Middle Left Drive (Y-Cable) | driveMBL | Master         | Yes - B        | Yes (Middle) | Torque  | No       |
| 6    | Launcher                             | launcher | No             | Yes - C        | No           | Unknown | No       |
| 7    | Front Left Drive                     | driveFL  | Yes - driveMBL | No             | No           | Torque  | No       |
| 8    | Front Right Drive                    | driveFR  | Yes - driveMR  | No             | No           | Torque  | Yes      |
| 9    | Arm Left                             | armL     | Master         | No             | Yes          | Unknown | Yes      |

*/


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"


bool driveIsTank = true;
bool driveWasPressed = false;

bool autoWasPressed = false;

const int armSpeed = 127;
const int armSlowSpeed = 50;
const int launcherSpeed = 100;

const float countsPerMotorRotation = 627.2; // Number of counts for one rotation of the motor (High strength)
const float distancePerWheelRotation = 2 * PI * 4 * 0.0254; //0.0254 to convert inches to meters

float distanceToDriveTicks(float distance) {
	return distance / distancePerWheelRotation * countsPerMotorRotation;
}


const int intakeSpeed = 100;


const int armLowPostPosition = 700;
const int integralArmMax = 20000;
float integralArm = 0;
int prevArmError = 0;




bool clawWasPressed = false;



void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks
  // running between Autonomous and Driver controlled modes. You will need to
  // manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;
  slaveMotor(armR, armL);

  slaveMotor(driveBR, driveMR);
  slaveMotor(driveFR, driveMR);

  slaveMotor(driveFL, driveMBL);
  // nMotorEncoder[armL] = 0;

/*
  while (true) {
		SensorValue[claw] = !SensorValue[claw];
		wait1Msec(1000);
	}*/
	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	// bDisplayCompetitionStatusOnLcd = false;

  // All activities that occur before the competition starts
  // Example: clearing encoders, setting servo positions, ...
}


void drive(int l, int r) {
		motor[driveMBL] = l;
		motor[driveMR] = r;
}


void arm(int speed) {
	motor[armL] = speed;
}

void armPID(int target, bool reset) {

	const float kP = 0.7;
	const float kI = 0.01;
	const float kD = 0.1;

	if (reset) {
		integralArm = 0;
		prevArmError = 0;
	}

	int error = 0; // target - nMotorEncoder[armL];
	integralArm = (integralArm + error) % integralArmMax; //Limit max value of integralArm


	int deltaError = error - prevArmError;
	prevArmError = error;

	int power = error * kP + integralArm * kI + deltaError * kD;
	arm(power);

	// writeDebugStreamLine("Motor: %d Sensor: %d Error: %d dt: %d Integral %d",power, nMotorEncoder[armL], error, deltaError, integralArm);

}


float integralDriveL = 0;
float integralDriveR = 0;
int prevDriveErrorL = 0;
int prevDriveErrorR = 0;

/*
int driveForwardsPID(int target, bool reset) {
	if (reset) {
			integralDriveL = integralDriveR = 0;
			prevDriveErrorL = prevDriveErrorR = 0;
	}


  // How will I implement this for both sides?
	return 0;
}

*/



void auto() {
	motor[launcher] = launcherSpeed;
	wait1Msec(3500);
	motor[launcher] = 0;
	/*drive(-80, -100);
	wait1Msec(3500);
	drive(0, 0);
	wait1Msec(300);
	drive(100, 100);
	wait1Msec(300);
	drive(0,0);

	*/
}

task autonomous()
{
  // ..........................................................................
  // Insert user code here.
  // ..........................................................................

  // Remove this function call once you have "real" code.
	auto();
}




task usercontrol()
{
	// auto();
  // User control code here, inside the loop
  while (true)
  {
  	wait1Msec(10);

  	if (vexRT[Btn8D] && !driveWasPressed) {
				driveIsTank = !driveIsTank;
				driveWasPressed = true;
  	}

  	else {
  		driveWasPressed = false;
  	}

  	if (driveIsTank) {
  		drive(vexRT[Ch3], vexRT[Ch2]);
  	}
  	else {
  		drive(vexRT[Ch3] + vexRT[Ch1], vexRT[Ch3] - vexRT[Ch1]);
  	}

/*
  	if (vexRT[Btn7U]) {
  		armPID(armLowPostPosition, autoWasPressed);
  		autoWasPressed = true;
  	}
  	else {
  		autoWasPressed = false;
*/
	  	if (vexRT[Btn5D] && vexRT[Btn5U]) {
	  		arm(armSlowSpeed); //If both buttons pressed go up slowly
	  	}	else if (vexRT[Btn5D]) {
	  		arm(-armSpeed);
	  	} else if (vexRT[Btn5U]) {
	  		arm(armSpeed);
	  	} else {
	  		arm(0);
	  	}


		motor[intake] = (vexRT[Btn6U] - vexRT[Btn6D]) * intakeSpeed; // Negative sucks it in

  	/*}*/

  	if (vexRT[Btn8U] && !clawWasPressed) {
  		SensorValue[claw] = !SensorValue[claw];
  		clawWasPressed = true;
  	} else if (!vexRT[Btn8U]) {
  		clawWasPressed = false;
  	}

  	motor[launcher] = (vexRT[Btn7D] - vexRT[Btn7U]) * launcherSpeed; // Positive draws it back
	}
}
