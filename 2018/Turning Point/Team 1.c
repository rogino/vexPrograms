#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl12, claw,           sensorDigitalOut)
#pragma config(Sensor, I2C_1,  armIME,         sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           driveMR,       tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           driveBR,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           armR,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           intake,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           driveMBL,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           launcher,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           driveFL,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           driveFR,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           armL,          tmotorVex393_MC29, PIDControl, reversed, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
To reduce the maximum current for each circuit breaker (ports 1-5, 6-10, power expander), we have tried to spread the load equally. Thus, each breaker only has two drive motors as they will be used extensively, and the load for the arm is spread out across two breaker.

Port 10 is unusable in the Cortex due to previous events, and as 10 motors are needed, a Y-cable is instead used.

http://markdowntable.com/

For motor naming, look at the robot from above with the cap flipper pointing upwards

| Port | Motor Description                    | Name     | Slave Motor    | Power Expander | IME          | Gearing | Reversed |
|------|--------------------------------------|----------|----------------|----------------|--------------|---------|----------|
| 1    | Middle Right Drive                   | driveMR  | Master         | No             | Yes          | Torque  | Yes      |
| 2    | Back Right Drive                     | driveBR  | Yes - driveMR  | No             | No           | Torque  | Yes      |
| 3    | Arm Right                            | armR     | Yes - armL     | No             | No           | Unknown | No       |
| 4    | Intake                               | intake   | No             | Yes - A        | No           | Unknown | No       |
| 5    | Back and Middle Left Drive (Y-Cable) | driveMBL | Master         | Yes - B        | Yes (Middle) | Torque  | No       |
| 6    | Launcher                             | launcher | No             | Yes - C        | No           | Unknown | No       |
| 7    | Front Left Drive                     | driveFL  | Yes - driveMBL | No             | No           | Torque  | No       |
| 8    | Front Right Drive                    | driveFR  | Yes - driveMR  | No             | No           | Torque  | Yes      |
| 9    | Arm Left                             | armL     | Master         | No             | Yes          | Unknown | Yes      |


## Controls
### Drive
8U: Switch between tank and arcade drive
During tank drive: left, right joysticks' vertical axis used (Ch3, Ch2)
During arcade drive: left joystick's vertical and right joystick's horizontal (Ch3, Ch1)

### Arm
5D, 5U: lower/raise arm
5U + 5D: arm goes up slowly
7R enables PID

### Intake
6D, 6U: D intakes, U reverses

### Claw
8D triggers pneumatics

### Launcher
7D draws it back

*/


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"


// ## Global Variables
// ### System
const int mainLoopDelay = 10;

// ### Drive
bool driveIsTank = true;
bool driveWasPressed = false;

// ### Intake
const int intakeSpeed = 100;

// ### Claw
bool clawWasPressed = false;

// ### Arm
const int armSpeed = 127;
const int armSlowSpeed = 50;
// #### Arm PID
long armError = 0;
long armIntegral = 0;
const long armMaxValue = 30000; // MAX: YOU MAY NEED TO MODIFY THIS
bool armPIDFirstTimePressed = true;
long armTarget = 0;


// ## Launcher
const int launcherSpeed = 100;



const float countsPerMotorRotation = 627.2; // Number of counts for one rotation of the motor (High strength)
const float distancePerWheelRotation = 2 * PI * 4 * 0.0254; //0.0254 to convert inches to meters

float distanceToDriveTicks(float distance) {
	return distance / distancePerWheelRotation * countsPerMotorRotation;
}





void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks
  // running between Autonomous and Driver controlled modes. You will need to
  // manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;
	slaveMotor(armR, armL);

	slaveMotor(driveBR, driveMR);
	slaveMotor(driveFR, driveMR);

	slaveMotor(driveFL, driveMBL);

    nMotorEncoder[armL] = 0; // Set the motor encoder to zero at startup as it should start in the same position for every match.


	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	// bDisplayCompetitionStatusOnLcd = false;

  // All activities that occur before the competition starts
  // Example: clearing encoders, setting servo positions, ...
}


void drive(int l, int r) {
	motor[driveMBL] = l;
	motor[driveMR] = r;
}


void arm(int speed) {
	motor[armL] = speed;
}

long getArmIMEValue() {
	return nMotorEncoder(armL);
}



void armPID(int target, long currentArmIMEValue, bool reset) {
	// MAX: YOU WILL NEED TO TWEAK THESE THREE VARIABLES
	const float kP = 0.7;
	const float kI = 0.01;
	const float kD = 0.1;

	if (reset) armError = armIntegral = 0;

	long error = target - currentArmIMEValue;

	armIntegral += error;

	if (armIntegral > armMaxValue) armIntegral = armMaxValue;
	else if (armIntegral < -armMaxValue) armIntegral = -armMaxValue;

	int armDerivative = error - armError;
	armError = error; // Update error

	int power = armError * kP + armIntegral * kI + armDerivative * kD;

	writeDebugStreamLine("Motor: %d Sensor: %d Error: %d dt: %d Integral %d", power, error + target, error, armDerivative, armIntegral);

	arm(power);
}


void auto() {
	motor[launcher] = launcherSpeed;
	wait1Msec(3500);
	motor[launcher] = 0;

}

task autonomous()
{
	auto();
}





task usercontrol()
{
	// auto();
  // setMotorTarget(armL, 500, 100, true);
	while (true)
	{
		wait1Msec(mainLoopDelay);

		// writeDebugStreamLine("IME Value: %d", getArmIMEValue());

		// armPID(1000, getArmIMEValue(), false); // Change the value of the number


		if (vexRT[Btn8U] && !driveWasPressed) {
			driveIsTank = !driveIsTank;
			driveWasPressed = true;
		}
		else driveWasPressed = false;


		if (driveIsTank) drive(vexRT[Ch3], vexRT[Ch2]);
		else drive(vexRT[Ch3] + vexRT[Ch1], vexRT[Ch3] - vexRT[Ch1]);


		if (vexRT[Btn7R]) {
			long currentIME = getArmIMEValue();
			if (armPIDFirstTimePressed) armTarget = currentIME;
			armPID(armTarget, currentIME, armPIDFirstTimePressed); // Target, actual value, reset if it is the first time at this position
			armPIDFirstTimePressed = false;

		} else { // Manual control
			armPIDFirstTimePressed = true; // Reset value

			if (vexRT[Btn5D] && vexRT[Btn5U]) arm(armSlowSpeed); //If both buttons pressed go up slowly
			else if (vexRT[Btn5D]) arm(-armSpeed);
			else if (vexRT[Btn5U]) arm(armSpeed);
			else arm(0);
		}


		motor[intake] = (vexRT[Btn6U] - vexRT[Btn6D]) * intakeSpeed; // Negative sucks it in


		if (vexRT[Btn8U] && !clawWasPressed) {
			SensorValue[claw] = !SensorValue[claw];
			clawWasPressed = true;
		}
		else if (!vexRT[Btn8D]) clawWasPressed = false;

  	motor[launcher] = vexRT[Btn7D] * launcherSpeed; // Positive draws it back
  }
}


/* Code I don't want to entirely remove yet
void armPID(int target, bool reset) {

	const float kP = 0.7;
	const float kI = 0.01;
	const float kD = 0.1;

	if (reset) {
		integralArm = 0;
		prevArmError = 0;
	}

	int error = 0; // target - nMotorEncoder[armL];
	integralArm = (integralArm + error) % integralArmMax; //Limit max value of integralArm


	int deltaError = error - prevArmError;
	prevArmError = error;

	int power = error * kP + integralArm * kI + deltaError * kD;
	arm(power);

	// writeDebugStreamLine("Motor: %d Sensor: %d Error: %d dt: %d Integral %d",power, nMotorEncoder[armL], error, deltaError, integralArm);

}


// AUTONOMOUS ROUTINE
	drive(-80, -100);
	wait1Msec(3500);
	drive(0, 0);
	wait1Msec(300);
	drive(100, 100);
	wait1Msec(300);
	drive(0,0);



*/
