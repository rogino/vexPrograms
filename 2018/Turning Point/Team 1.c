#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    powerExpanderBatterySensor, sensorAnalog)
#pragma config(Sensor, dgtl12, claw,           sensorDigitalOut)
#pragma config(Sensor, I2C_1,  driveRIme,      sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  armLIme,        sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  driveLIme,      sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           driveMR,       tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port2,           driveBR,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           armR,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           intake,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           driveMBL,      tmotorVex393_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port6,           launcher,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           driveFL,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           driveFR,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           armL,          tmotorVex393_MC29, reversed, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

// TODO: limit to legal height under some conditions
// TODO: Buttons to get to max height/high post and mid post
// TODO: Button to reset arm IME to zero. Cortex?
// TODO: 36 inch max expansion in any horizontal dimension.

/*
To reduce the maximum current for each circuit breaker (ports 1-5, 6-10, power expander), we have tried to spread the load equally. Thus, each breaker only has two drive motors as they will be used extensively, and the load for the arm is spread out across two breaker.

Port 10 is unusable in the Cortex due to previous events, and as 10 motors are needed, a Y-cable is instead used.

http://markdowntable.com/

For motor naming, look at the robot from above with the cap flipper pointing upwards

| Port | Motor Description                    | Name     | Slave Motor    | Power Expander | IME              | Gearing | Reversed |
|------|--------------------------------------|----------|----------------|----------------|------------------|---------|----------|
| 1    | Middle Right Drive                   | driveMR  | Master         | No             | Yes - 1          | Torque  | Yes      |
| 2    | Back Right Drive                     | driveBR  | Yes - driveMR  | No             | No               | Torque  | Yes      |
| 3    | Arm Right                            | armR     | Yes - armL     | No             | No               | Unknown | No       |
| 4    | Intake                               | intake   | No             | Yes - A        | No               | Torque  | Yes      |
| 5    | Back and Middle Left Drive (Y-Cable) | driveMBL | Master         | Yes - B        | Yes (Middle) - 3 | Torque  | No       |
| 6    | Launcher                             | launcher | No             | Yes - C        | No               | Unknown | Yes      |
| 7    | Front Left Drive                     | driveFL  | Yes - driveMBL | No             | No               | Torque  | No       |
| 8    | Front Right Drive                    | driveFR  | Yes - driveMR  | No             | No               | Torque  | Yes      |
| 9    | Arm Left                             | armL     | Master         | No             | Yes - 3          | Unknown | Yes      |


## Controls
### Drive
During tank drive: left, right joysticks' vertical axis used (Ch3, Ch2)
During arcade drive: left joystick's vertical and right joystick's horizontal (Ch3, Ch1)
*/


// ## Global Variables
// ### Button Constants and related functions
// This stops the button from being updated only in one place
const short BTN_TRIGGER_PNEUMATICS = Btn8D;
const short BTN_DRAW_LAUNCHER_BACK = Btn7D;

const short BTN_LOWER_ARM = Btn5D;
const short BTN_RAISE_ARM = Btn5U;

const short BTN_TOGGLE_LOCK_ARM_PID = Btn6D;
const short BTN_TOGGLE_POST_ARM_PID = Btn8L;

const short BTN_TOGGLE_DRIVE_MODE = Btn8U;

const short BTN_INTAKE_IN = Btn6U;
const short BTN_INTAKE_OUT = Btn7R;

bool btnComboAutonomous() { return vexRT[Btn7L] && vexRT[Btn8R]; } // Triggers autonomous. Needed when there is no field control.
bool btnComboRaiseArmSlowly() { return vexRT[BTN_LOWER_ARM] && vexRT[BTN_RAISE_ARM]; } // Raises arm slowly

// ## Maths functions

bool signsDifferent(int num1, int num2) {
	return num1 >= 0 && num2 < 0 || num2 >= 0 && num1 < 0;
}


// ## Struct definitions


typedef struct {
	bool previouslyPressed;
	bool isTrue;
} ToggleButton;

// RobotC doesn't support functions returning structs... even though the official documentation has an example of this
void initializeToggleButton(struct ToggleButton* toggleButton, bool initialState) {
	toggleButton->previouslyPressed = false; // Always starts with no press
	toggleButton->isTrue = initialState;
}


// Updates the state of a ToggleButton
// Args. toggleButton: pointer to ToggleButton struct; buttonIsPressed: whether or not the button is pressed
// Return. true if the state has been changed, false if not
bool toggleButtonSetter(struct ToggleButton* toggleButton, bool buttonIsPressed) {
	if (buttonIsPressed && !toggleButton->previouslyPressed) { // Check if pressed and wasn't previously pressed
		toggleButton->previouslyPressed = true; // Now, have previously pressed it.
		toggleButton->isTrue = !toggleButton->isTrue; // If so, toggle the value and return true
		return true;
	}
	toggleButton->previouslyPressed = buttonIsPressed; // If pressed, previously pressed is true. If not pressed, false. So just set to buttonIsPressed.
	return false; // No change to value, so return false
}


typedef struct {
	bool previouslyPressed;
	ubyte state;
	ubyte numStates;
} NToggleButton;

void initializeNToggleButton(struct NToggleButton* nToggleButton, ubyte initialState, ubyte numStates) {
	nToggleButton->previouslyPressed = false;
	nToggleButton->state = initialState;
	nToggleButton->numStates = numStates;
}
bool NToggleButtonSetter(struct NToggleButton* nToggleButton, bool buttonIsPressed) {
	if (buttonIsPressed && !nToggleButton->previouslyPressed) {
		nToggleButton->previouslyPressed = true;
		nToggleButton->state = (nToggleButton->state + 1) % nToggleButton->numStates;
		return true;
	}
	nToggleButton->previouslyPressed = buttonIsPressed;
	return false;
}



typedef struct {
	int error;
	int integral;
	short derivative;
	bool errorSignPositive; // Sign of the error

	int target;

	// Constants that need to be set
	float P;
	float I;
	float D;
	bool powerNeededToHoldPosition; // Whether or not power is needed to hold at the current position. If not, the integral will be set to zero when the sign of the error changes.
	int maxIntegral; // Max value the integral can take
	short maxPower; // Max motor strength

	short numLittleMovement; // Number of consecutive runs in which there has been little movement (abs(derivative) < something)
	short numLittleMovementForEnd; // Number of consecutive runs in which there is little movement for PID to finish
	short littleMovementDefinition; // Cannot change by more than this amount to be defined as little movement
	bool pidFinished; // PID has ended. Not neccesarily goal reached, but no/little movement for some time
	short power; // Output power
} PidStruct;

void resetPid(struct PidStruct *pid) {
	pid->error = pid->integral = pid->derivative = pid->power = pid->numLittleMovement = 0;
	pid->pidFinished = false;
	pid->errorSignPositive = true;
}

void initializePidStruct(struct PidStruct* pid, float P, float I, float D, bool powerNeededToHoldPosition, int maxIntegral, short maxPower) {
	pid->P = P;
	pid->I = I;
	pid->D = D;
	pid->powerNeededToHoldPosition = powerNeededToHoldPosition;
	pid->maxIntegral = maxIntegral;
	pid->maxPower = maxPower;
	pid->littleMovementDefinition = 3;
	pid->numLittleMovementForEnd = 50;

	resetPid(pid); // need to initialize all variables
}


short runPid(struct PidStruct *pid, int currentImeValue) {
	if (pid->pidFinished) return 0;

	int error = pid->target - currentImeValue;

	pid->integral += error;

	if (abs(pid->integral) > pid->maxIntegral) pid->integral = 0; // If too large, set to zero
	if (!pid->powerNeededToHoldPosition && signsDifferent(error, pid->error)) pid->integral = 0; // If sign changes, set integral to zero

	pid->derivative = error - pid->error; // Find the rate of change. pid->error gives the previous error

	if (abs(pid->derivative) < pid->littleMovementDefinition) pid->numLittleMovement++;
	else pid->numLittleMovement = 0; // Reset if movement larger
	if (pid->numLittleMovement > pid->numLittleMovementForEnd) pid->pidFinished = true; //Stop movement

	pid->error = error; // Set the new error

	short power = pid->error * pid->P + pid->integral * pid->I + pid->derivative * pid->D;

	// Limit power
	if (power > pid->maxPower) power = pid->maxPower;
	else if (power < -pid->maxPower) power = -pid->maxPower;

	pid->power = power;
	return power;
}


// ### PID variables
const float COUNTS_PER_MOTOR_ROTATION[] = {627.2, 392, 261.333 }; // Number of counts for one rotation of the motor
enum gearingTypes { TORQUE, HIGHSPEED, TURBO }; // Enum corresponding to the array above. Float not integral so can't use enum with custom values

// ### System
const short MAIN_LOOP_DELAY = 10; // PID done with 10msec main loop

// ### Drive
struct ToggleButton driveIsTank;

const float WHEEL_RADIUS_INCHES = 2;
const float METERS_PER_WHEEL_ROTATION = 2 * PI * WHEEL_RADIUS_INCHES * 0.0254; //0.0254 to convert inches to meters
const short DRIVE_MOTORS_GEARING = TORQUE; // Drive using torque motors. Declared as short instead of `enum gearingTypes varName` as I want to use it as an index
int distanceToDriveTicks(float distance) {
	return (int) (COUNTS_PER_MOTOR_ROTATION[DRIVE_MOTORS_GEARING] * distance / METERS_PER_WHEEL_ROTATION); // May be off by up to *gasp* 1 tick due to rounding down
}

// ### Drive Pid
struct PidStruct driveLPid;
struct PidStruct driveRPid;

// ### Intake
const short INTAKE_SPEED = 100;

// ### Claw
struct ToggleButton ClawClosed;

// ### Arm
const short ARM_SPEED = 127;
const short ARM_SLOW_SPEED = 50;

// #### Arm IME
// 0 = very bottom
const short ARM_MAX_HEIGHT = 1300; // Max ~1370, but momentum so make it a bit lower
const short ARM_HIGH_POST_HEIGHT = 1224;
const short ARM_LOW_POST_HEIGHT = 820;

// #### Arm PID
enum armPidStateEnum { ARM_PID_DISABLED, ARM_PID_LOCKED, ARM_PID_LOW_POST, ARM_PID_HIGH_POST };
enum armPidStateEnum armPidState = ARM_PID_DISABLED; // initial state

struct ToggleButton armPidLockToggler;
struct ToggleButton armPidPostToggler;

struct PidStruct armPid;


// ## Launcher
const short LAUNCHER_SPEED = 100;






task BatteryVoltageLCD() {
	string line;
	float primary;
	float secondary;
	while (true) {
		wait1Msec(1000); // Updates every second
		clearLCDLine(0); // clear top line

		short powerExpanderRaw = SensorValue[powerExpanderBatterySensor];
		if (powerExpanderRaw < 300) {
			sprintf(line, "2ND BATTERY");
		} else {
			primary = nImmediateBatteryLevel / 1000.0;
			secondary = powerExpanderRaw / 180.0; // Vex forums say 270.0, but differs between cortex and power expander. 1.4-1.6 seems to be around the difference multiplier
			sprintf(line, "1: %.1f; 2: %.1f", primary, secondary);
		}

		displayLCDString(0, 0, line);
	}
	// endTimeSlice() needed if there is no wait

}


void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks
	// running between Autonomous and Driver controlled modes. You will need to
	// manage all user created tasks if set to false.
	slaveMotor(driveFR, driveMR);
	bStopTasksBetweenModes = true;
	slaveMotor(armR, armL);

	slaveMotor(driveBR, driveMR);

	slaveMotor(driveFL, driveMBL);

	resetMotorEncoder(armL); // Otherwise, this returns 0. Very fustrating
	resetMotorEncoder(driveMBL);
	resetMotorEncoder(driveMR);

	bLCDBacklight = true; // Turn on backlight

	startTask(BatteryVoltageLCD);

	// Initialization of structs (needs to occur within a function)
	initializeToggleButton(&driveIsTank, true); // default tank drive
	initializeToggleButton(&armPidLockToggler, false); // Default values for Lock and Post Toggler doesn't actually matter-just want to know when the state changes
	initializeToggleButton(&armPidPostToggler, false);
	initializeToggleButton(&ClawClosed, false); // Same for claw

	initializePidStruct(&armPid, 0.75, 0.008, 1, true, 30000, 127);
	initializePidStruct(&driveLPid, 0.3, 0, 1, false, 10000, 127);
	memcpy(&driveRPid, &driveLPid, sizeof(PidStruct)); // Copy settings for left to right. Can do this as the struct has no pointers so values, not references are used
	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	// bDisplayCompetitionStatusOnLcd = false;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...

}


void drive(short l, short r) {
	motor[driveMBL] = l;
	motor[driveMR] = r;
}

// DistanceMeters ignored if reset is false
void driveStraight(bool reset, float distanceMeters) {
	if (reset) {
		resetPid(&driveLPid);
		resetPid(&driveRPid);
		resetMotorEncoder(driveMBL);
		resetMotorEncoder(driveMR);

		int numTicks = distanceToDriveTicks(distanceMeters);

		driveLPid.target = numTicks;
		driveRPid.target = numTicks;
	}

	short l = runPid(&driveLPid, nMotorEncoder(driveMBL));
	short r = runPid(&driveRPid, nMotorEncoder(driveMR));

	/*
	clearLCDLine(0);
	string str;
	sprintf(str, "L:%d %d;R:%d %d;%d", l, driveLPid.pidFinished, r, driveRPid.pidFinished, driveRPid.D);
	clearLCDLine(1);
	displayLCDString(1,0,str);*/

	datalogDataGroupStart();
	datalogAddValue(0, l);
	datalogAddValue(1, driveLPid.error);
	datalogAddValue(2, driveLPid.derivative);
	datalogAddValue(3, driveLPid.numLittleMovement);
	datalogAddValue(4, r);
	datalogAddValue(5, driveRPid.error);
	datalogAddValue(6, driveRPid.derivative);
	datalogAddValue(7, driveRPid.numLittleMovement);
	datalogDataGroupEnd();
	drive(l, r);

}


void driveTank() { drive(vexRT[Ch3], vexRT[Ch2]); }
void driveArcade() { drive(vexRT[Ch3] + vexRT[Ch1], vexRT[Ch3] - vexRT[Ch1]); }



void arm(short speed) { motor[armL] = speed; }


void armLogic() {
	if (nLCDButtons == 1) resetMotorEncoder(armL); // Reset IME zero point if LCD LEFT BUTTON pressed (2=center,4=right)


	short armImeValue = nMotorEncoder(armL); // Short as arm cannot freely rotate (like drive) so range will be limited to < 32000

	if (toggleButtonSetter(&armPidLockToggler, vexRT[BTN_TOGGLE_LOCK_ARM_PID])) { // Runs if the value changes
		if (armPidState == ARM_PID_LOCKED) armPidState = ARM_PID_DISABLED; // Disable PID if currently locked
		else {
			armPidState = ARM_PID_LOCKED; // If not locked, lock
			resetPid(&armPid);
			armPid.target = armImeValue;
		}
	}

	if (toggleButtonSetter(&armPidPostToggler, vexRT[BTN_TOGGLE_POST_ARM_PID])) {
		switch(armPidState) {
			case ARM_PID_LOW_POST: // If currently low, next state is high
				armPidState = ARM_PID_HIGH_POST;
				resetPid(&armPid);
				armPid.target = ARM_HIGH_POST_HEIGHT;
				break;

			case ARM_PID_HIGH_POST: // If currently high, disable
				armPidState = ARM_PID_DISABLED;
				break;

			default:
				armPidState = ARM_PID_LOW_POST;
				resetPid(&armPid);
				armPid.target = ARM_LOW_POST_HEIGHT;
				break;
		}
	}


	if (vexRT[BTN_RAISE_ARM] || vexRT[BTN_LOWER_ARM]) armPidState = ARM_PID_DISABLED; // If either of the arm buttons are pressed, disable Pid

	short power;
	if (armPidState != ARM_PID_DISABLED) { // If enabled, call the PID function
		power = runPid(&armPid, armImeValue);
	}
	else {
		if (btnComboRaiseArmSlowly()) power = ARM_SLOW_SPEED; //If both buttons pressed go up slowly
		else if (vexRT[BTN_LOWER_ARM]) power = -ARM_SPEED;
		else if (vexRT[BTN_RAISE_ARM]) power = ARM_SPEED;
		else power = 0;
	}


	power = (power > 0 && armImeValue > ARM_MAX_HEIGHT)? 0: power; // If going up and arm value greater than maximum, disable it by setting
	// TODO? Limit bottom as well?
	arm(power);

}



void auto() {
	motor[launcher] = LAUNCHER_SPEED;
	wait1Msec(3500);
	motor[launcher] = 0;

}

task autonomous()
{
	auto();
}




char PIDTypeFromShort(short a) {
	if (a == 0) return 'P';
	if (a == 1) return 'I';
	if (a == 2) return 'D';
	return '?';
}
float PIDValFromShort(short a, struct PidStruct* struc) {
	if (a == 0) return struc->P;
	if (a == 1) return struc->I;
	if (a == 2) return struc->D;
	return 0;
}

float adder(float val) {
			return val + 0.005 * ((nLCDButtons == 4)?1:-1);
		}

task usercontrol()
{
	bool direction = true;
	string lcdLineTwo;
	struct ToggleButton temp;
	initializeToggleButton(&temp, false);

	struct NToggleButton PIDSwitcher;
	initializeNToggleButton(&PIDSwitcher, 0, 3);


	while (true)
	{
		// ### Random
		wait1Msec(MAIN_LOOP_DELAY);
		clearLCDLine(1);
		//sprintf(lcdLineTwo, "A:%d;L:%d;R:%d", nMotorEncoder(armL), nMotorEncoder(driveMBL), nMotorEncoder(driveMR));
		// sprintf(lcdLineTwo, "%.3f,%d,%d", driveRPid.I, driveLPid.target - nMotorEncoder(driveMBL), driveRPid.target - nMotorEncoder(driveMR));
		sprintf(lcdLineTwo, "%c:%.3f,%d,%d", PIDTypeFromShort(PIDSwitcher.state), PIDValFromShort(PIDSwitcher.state, &driveRPid), driveLPid.target - nMotorEncoder(driveMBL), driveRPid.target - nMotorEncoder(driveMR));
		displayLCDString(1, 0, lcdLineTwo);

		if (btnComboAutonomous()) auto(); // For when there is no field control. Start auto with 7L and 8R

		// ### Drive
		/*
		toggleButtonSetter(&driveIsTank, vexRT[BTN_TOGGLE_DRIVE_MODE]);
		if (driveIsTank.isTrue) driveTank();
		else driveArcade();
*/
		NToggleButtonSetter(&PIDSwitcher, nLCDButtons == 2);

		if (toggleButtonSetter(&temp, vexRT[Btn7U]) && temp.isTrue) {
			driveStraight(true, 0.3 * (direction?1:-1));
			direction = !direction;
		}
		else if (temp.isTrue) driveStraight(false, 0);
		else drive(0,0);


		if (nLCDButtons == 1 || nLCDButtons == 4) {
			switch(PIDSwitcher.state) {
				case 0:
					driveRPid.P = driveLPid.P = adder(driveRPid.P);
					break;
				case 1:
					driveRPid.I = driveLPid.I = adder(driveRPid.I);
					break;
				case 2:
					driveRPid.D = driveLPid.D = adder(driveRPid.D);
					break;
			}
		}

		// ### Arm
		armLogic();



	    // ### Intake
		motor[intake] = (vexRT[BTN_INTAKE_IN] - vexRT[BTN_INTAKE_OUT]) * INTAKE_SPEED;

		// ### Pneumatics
		if (toggleButtonSetter(&ClawClosed, vexRT[BTN_TRIGGER_PNEUMATICS])) SensorValue[claw] = !SensorValue[claw]; //Switch value of claw


		// ### Launcher
		motor[launcher] = (vexRT[BTN_DRAW_LAUNCHER_BACK] - vexRT[Btn7U]) * LAUNCHER_SPEED; // Draw the launcher back // TEMP TODOD!!!!!!!!!!!!!!!!!
	}
}




// Multistate toggler

// typedef struct {
// 	bool previouslyPressed;
// 	ubyte state;
// 	ubyte numStates;
// } NToggleButton;

// void initializeNToggleButton(struct NToggleButton* nToggleButton, ubyte initialState, ubyte numStates) {
// 	nToggleButton->previouslyPressed = false;
// 	nToggleButton->state = initialState;
// 	nToggleButton->numStates = numStates;
// }
// bool NToggleButtonSetter(struct NToggleButton* nToggleButton, bool buttonIsPressed) {
// 	if (buttonIsPressed && !nToggleButton->previouslyPressed) {
// 		nToggleButton->previouslyPressed = true;
// 		nToggleButton->state = (nToggleButton->state + 1) % nToggleButton->numStates;
// 		return true;
// 	}
// 	nToggleButton->previouslyPressed = buttonIsPressed;
// 	return false;
// }
