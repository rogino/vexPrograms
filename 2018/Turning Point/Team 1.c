#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    powerExpanderBatterySensor, sensorAnalog)
#pragma config(Sensor, dgtl1,  launcherBackSensor, sensorTouch)
#pragma config(Sensor, dgtl2,  claw,           sensorDigitalOut)
#pragma config(Sensor, I2C_1,  driveLIme,      sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  armLIme,        sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  driveRIme,      sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           driveFL,       tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           driveBR,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           armR,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           intake,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           driveMBL,      tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port6,           launcher,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           driveMR,       tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_3)
#pragma config(Motor,  port8,           driveFR,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           armL,          tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

#include "ToggleButton.c"
#include "PidStruct.c"
// #include "Helper.c"
#include "NToggleButton.c"

// TODO: limit to legal height under some conditions
// TODO: Buttons to get to max height/high post and mid post
// TODO: Button to reset arm IME to zero. Cortex?
// TODO: 36 inch max expansion in any horizontal dimension.

/*
To reduce the maximum current for each circuit breaker (ports 1-5, 6-10, power expander), we have tried to spread the load equally. Thus, each breaker only has two drive motors as they will be used extensively, and the load for the arm is spread out across two breaker.

Port 10 is unusable in the Cortex due to previous events, and as 10 motors are needed, a Y-cable is instead used.

http://markdowntable.com/

For motor naming, look at the robot from above with the cap flipper pointing upwards

| Port | Motor Description                    | Name     | Slave Motor    | Power Expander | IME              | Gearing | Reversed |
|------|--------------------------------------|----------|----------------|----------------|------------------|---------|----------|
| 1    | Front Left Drive                     | driveFL  | Yes - driveMBL | No             | No               | Torque  | No       |
| 2    | Back Right Drive                     | driveBR  | Yes - driveMR  | No             | No               | Torque  | Yes      |
| 3    | Arm Right                            | armR     | Yes - armL     | No             | No               | Unknown | No       |
| 4    | Intake                               | intake   | No             | Yes - A        | No               | Torque  | Yes      |
| 5    | Back and Middle Left Drive (Y-Cable) | driveMBL | Master         | Yes - B        | Yes (Middle) - 3 | Torque  | No       |
| 6    | Launcher                             | launcher | No             | Yes - C        | No               | Torque  | Yes      |
| 7    | Middle Right Drive                   | driveMR  | Master         | No             | Yes - 1          | Torque  | Yes      |
| 8    | Front Right Drive                    | driveFR  | Yes - driveMR  | No             | No               | Torque  | Yes      |
| 9    | Arm Left                             | armL     | Master         | No             | Yes - 2          | Unknown | Yes      |


## Controls
### Drive
During tank drive: left, right joysticks' vertical axis used (Ch3, Ch2)
During arcade drive: left joystick's vertical and right joystick's horizontal (Ch3, Ch1)

### LCD Display
Left: Reset arm IME zero position
Center: Start autonomous
Right: Change autonomous position
*/


// ## Global Variables
// ### Button Constants and related functions
// This stops the button from being updated only in one place
const short BTN_TOGGLE_PNEUMATICS = Btn8D;

const short BTN_DRAW_LAUNCHER_FORWARDS = Btn7U;
const short BTN_TOGGLE_LAUNCHER_AUTO = Btn7L;

const short BTN_LOWER_ARM = Btn5D;
const short BTN_RAISE_ARM = Btn5U;

const short BTN_TOGGLE_LOCK_ARM_PID = Btn6D;
const short BTN_TOGGLE_POST_ARM_PID = Btn8L;

const short BTN_TOGGLE_DRIVE_REVERSED = Btn8R;
const short BTN_TOGGLE_DRIVE_SENSITIVITY = Btn8U;

const short BTN_INTAKE_IN = Btn6U;
const short BTN_INTAKE_OUT = Btn7R;

bool btnComboAutonomous() { return vexRT[Btn7L] && vexRT[Btn8R]; } // Triggers autonomous. Needed when there is no field control.
bool btnComboRaiseArmSlowly() { return vexRT[BTN_LOWER_ARM] && vexRT[BTN_RAISE_ARM]; } // Raises arm slowly


// ### PID variables
// ### System
const short MAIN_LOOP_DELAY = 10; // Note: PID calibrated with 10msec main loop
string line1;

// #### Autonomous
struct NToggleButton toggleAutonomousMode;

void lcdPrintAutonomousMode() { // Can't have an array of strings, so doing this instead
	clearLCDLine(1);
	string line2;
	switch(toggleAutonomousMode.state) {
		case 0: line2 = "Blue Near"; break;
		case 1: line2 = "Blue Far" ; break;
		case 2: line2 = "Red Near" ; break;
		case 3: line2 = "Red Far"  ; break;
	}
	displayLCDString(1,0,line2);
}
void autonomousWrapper();

// ### Drive
struct ToggleButton toggleDriveReversed; // Reverses back and front (for launcher)
struct ToggleButton toggleDriveSensitivity; // Makes it less sensitive for more accurate driving
const float driveLowSensitivityMultiplier = 0.3;

int distanceToDriveTicks(float distanceMeters) {
	// From testing with torque, 1m=1800 ticks
	// Thus, ticks = distance * 1800
	return distanceMeters * 1800;
}

// ### Drive Pid
struct PidStruct driveLPid;
struct PidStruct driveRPid;
void setDrivePIDSettings(float P, float I, float D, int maxIntegral, short maxPower) {
	initializePidStruct(&driveLPid, P, I, D, false, maxIntegral, maxPower);
	memcpy(&driveRPid, &driveLPid, sizeof(PidStruct)); // Copy settings for left to right. Can do this as the struct has no pointers so values, not references are used
}

// ### Intake
const short INTAKE_SPEED = 100;

// ### Claw
struct ToggleButton toggleClawState;

// ### Launcher
const short LAUNCHER_SPEED = 100;
const short LAUNCHER_AUTO_SPEED = 80;
typedef struct {
	struct ToggleButton autoEnabled;
	struct ToggleButton sensorTransition;
	ubyte numTimesTrue; // Needs to be true once or twice depending on if primed/unprimed
	ubyte numTimesTrueNeeded;
	bool primedToLaunch; // If it is primed to launch (or should have been but the rubber bands drew it forwards)

} LauncherStruct;
struct LauncherStruct launcherStruct;

// ### Arm
const short ARM_SPEED = 127;
const short ARM_SLOW_SPEED = 50;


// #### Arm IME
// 0 = very bottom
const short ARM_MAX_HEIGHT = 1300; // Max ~1370, but momentum so make it a bit lower
const short ARM_HIGH_POST_HEIGHT = 1210;
const short ARM_LOW_POST_HEIGHT = 800;


// #### Arm PID
enum armPidStateEnum { ARM_PID_DISABLED, ARM_PID_LOCKED, ARM_PID_LOW_POST, ARM_PID_HIGH_POST };
enum armPidStateEnum armPidState = ARM_PID_DISABLED; // initial state

struct ToggleButton toggleArmPidLock;
struct ToggleButton toggleArmPidPost;
struct ToggleButton toggleArmButtonsPressed;

struct PidStruct armPid;



task BatteryVoltageLCD() {
	string line;
	float primary;
	float secondary;
	while (true) {
		wait1Msec(1000); // Updates every second
		clearLCDLine(0); // clear top line

		short powerExpanderRaw = SensorValue[powerExpanderBatterySensor];
		if (powerExpanderRaw < 300) {
			sprintf(line, "CHECK BATTERY");
		} else {
			primary = nImmediateBatteryLevel / 1000.0;
			secondary = powerExpanderRaw / 180.0; // Vex forums say 270.0, but differs between cortex and power expander. 1.4-1.6 seems to be around the difference multiplier
			sprintf(line, "1: %.1f; 2: %.1f", primary, secondary);
		}

		displayLCDString(0, 0, line);
	}
	// endTimeSlice() needed if there is no wait

}


void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks
	// running between Autonomous and Driver controlled modes. You will need to
	// manage all user created tasks if set to false.
	slaveMotor(driveFR, driveMR);
	bStopTasksBetweenModes = true;
	slaveMotor(armR, armL);

	slaveMotor(driveBR, driveMR);

	slaveMotor(driveFL, driveMBL);

	resetMotorEncoder(armL); // Otherwise, this returns 0. Very fustrating
	resetMotorEncoder(driveMBL);
	resetMotorEncoder(driveMR);

	bLCDBacklight = true; // Turn on backlight

	// startTask(BatteryVoltageLCD);

	// Initialization of structs (needs to occur within a function)
	initializeToggleButton(&toggleDriveSensitivity, false); // default low sensntivity
	initializeToggleButton(&toggleDriveReversed, false);

	initializeToggleButton(&toggleArmButtonsPressed, false);
	initializeToggleButton(&toggleArmPidPost, false);
	initializeToggleButton(&toggleArmPidLock, false); // Default values for Lock and Post Toggler doesn't actually matter-just want to know when the state changes
	initializeToggleButton(&toggleClawState, false); // Same for claw


	initializeToggleButton(&launcherStruct.autoEnabled, false);
	initializeToggleButton(&launcherStruct.sensorTransition, false);
	launcherStruct.numTimesTrue = launcherStruct.numTimesTrueNeeded = 0; // Initialization

	initializeNToggleButton(&toggleAutonomousMode, 1, 4);

	initializePidStruct(&armPid, 0.72, 0.008, 1, true, 30000, 127);
	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	// bDisplayCompetitionStatusOnLcd = false;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...

}


void drive(short l, short r, bool lowSensitivity) {
	motor[driveMBL] = (int)(l * (lowSensitivity? driveLowSensitivityMultiplier: 1));
	motor[driveMR] =  (int)(r * (lowSensitivity? driveLowSensitivityMultiplier: 1));
}



void arm(short speed) { motor[armL] = speed; }


void armLogic() {
	if (nLCDButtons == 1) resetMotorEncoder(armL); // Reset IME zero point if LCD LEFT BUTTON pressed (2=center,4=right)


	short armImeValue = nMotorEncoder(armL); // Short as arm cannot freely rotate (like drive) so range will be limited to < 32000

	if (toggleButtonSetter(&toggleArmPidLock, vexRT[BTN_TOGGLE_LOCK_ARM_PID])) { // Runs if the value changes
		if (armPidState == ARM_PID_LOCKED) armPidState = ARM_PID_DISABLED; // Disable PID if currently locked
		else {
			armPidState = ARM_PID_LOCKED; // If not locked, lock
			resetPid(&armPid);
			setPidTarget(&armPid, armImeValue);
		}
	}

	if (toggleButtonSetter(&toggleArmPidPost, vexRT[BTN_TOGGLE_POST_ARM_PID])) {
		switch(armPidState) {
			case ARM_PID_LOW_POST: // If currently low, next state is high
				armPidState = ARM_PID_HIGH_POST;
				resetPid(&armPid);
				setPidTarget(&armPid, ARM_HIGH_POST_HEIGHT);
				break;

			case ARM_PID_HIGH_POST: // If currently high, disable
				armPidState = ARM_PID_DISABLED;
				break;

			default:
				armPidState = ARM_PID_LOW_POST;
				resetPid(&armPid);
				setPidTarget(&armPid, ARM_LOW_POST_HEIGHT);
				break;
		}
	}
	/*
	if PID button pushed while raise/lower buttons pushed, PID is turned on
	*/
	if (toggleButtonSetter(&toggleArmButtonsPressed, vexRT[BTN_RAISE_ARM] || vexRT[BTN_LOWER_ARM]) && toggleArmButtonsPressed.isTrue) armPidState = ARM_PID_DISABLED; // When manual button is pushed down, disable armPID. However, if the armPID button is pushed while one of the manual buttons are pushed, PID will be enabled and as the state is not changed, PID will remain unabled until the user releases the manual button(s) and presses on of them again, or pressed the PID button again.


	short power;
	if (armPidState != ARM_PID_DISABLED) { // If enabled, call the PID function
		power = runPid(&armPid, armImeValue);
	}
	else {
		if (btnComboRaiseArmSlowly()) power = ARM_SLOW_SPEED; //If both buttons pressed go up slowly
		else if (vexRT[BTN_LOWER_ARM]) power = -ARM_SPEED;
		else if (vexRT[BTN_RAISE_ARM]) power = ARM_SPEED;
		else power = 0;
	}


	power = (power > 0 && armImeValue > ARM_MAX_HEIGHT)? 0: power; // If going up and arm value greater than maximum, disable it by setting
	// TODO? Limit bottom as well?
	arm(power);

}

bool launcherSensor() {
	return (bool)SensorValue[launcherBackSensor];
}

/*
Launcher
Two main states: primed and unprimed.
If unprimed, the launcher is drawn back until the sensor is activated. If the sensor fails to activate, the user can tap the button again to disable the autonomous draw back
If primed, there are two substates
If the launcher slips between the time the launcher is drawn back and fired, causing the sensor to return false, the launcher will be drawn 'back' until the sensor is activated twice, once to fire and the second time to draw it back
If not, the launcher will be drawn back until the sensor is re-activated.
*/
void launcherLogic() {
	// Seeing if the sensor value has changed
	bool launcherSensorHasChanged = toggleButtonSetter(&launcherStruct.sensorTransition, launcherSensor()); // Update the ToggleButton struct, see if the sensor has changed. This needs to occur regeardless of if auto is on or not so that it can be set to false when auto is off.

	if (launcherStruct.autoEnabled.isTrue && launcherSensorHasChanged && launcherSensor()) {
		// Using SensorValue not ToggleButton.isTrue as only using the struct so this runs once per press
		launcherStruct.numTimesTrue += 1; // If state has transitioned and the sensor is now pressed, then need to increment counter
		if (launcherStruct.numTimesTrue >= launcherStruct.numTimesTrueNeeded) { // If goal reached
			launcherStruct.autoEnabled.isTrue = false; // Disable auto; stop the motors
			launcherStruct.primedToLaunch = true; // If auto is enabled, it should always end in the drawn position
		}
	}

	// Seeing if the user has pressed the auto button
	if (toggleButtonSetter(&launcherStruct.autoEnabled, vexRT[BTN_TOGGLE_LAUNCHER_AUTO]) && launcherStruct.autoEnabled.isTrue) { // Button has been pressed and autonomous is now enabled
		launcherStruct.numTimesTrue = 0; // Reset counter. Do it on enable rather than disable as multiple things can disable it but only be enabled here
		launcherStruct.numTimesTrueNeeded = 1 + (launcherStruct.primedToLaunch && !launcherSensor()); // If primed but there has been slip, causing the sensor to not be depressed, then true needs to be hit twice rather than once
	}

	if (vexRT[BTN_DRAW_LAUNCHER_FORWARDS]) {
		launcherStruct.autoEnabled.isTrue = launcherStruct.primedToLaunch = false; // disable auto, set to undrawn if there is any input.
		motor[launcher] = -LAUNCHER_SPEED; // Drive forwards. To drive it back, use the auto thing
	}
	else if (launcherStruct.autoEnabled.isTrue) {
		motor[launcher] = LAUNCHER_AUTO_SPEED;
	}
	else motor[launcher] = 0;
}




void runDrivePid() {
	short l = runPid(&driveLPid, nMotorEncoder(driveMBL));
	short r = runPid(&driveRPid, nMotorEncoder(driveMR));

	drive(l, r, false);
}

void initializeDrivePID(int ticksL, int ticksR) {
	resetPid(&driveLPid);
	resetPid(&driveRPid);
	resetMotorEncoder(driveMBL);
	resetMotorEncoder(driveMR);
	setPidTarget(&driveLPid, ticksL);
	setPidTarget(&driveRPid, ticksR);
}
void initializeDriveStraight(float distanceMeters) {
	// setDrivePIDSettings(0.16, 0.006, 6, 30000, 127); Pretty Good
	// setDrivePIDSettings(0.16, 0.01, 6, 30000, 127); Good for 1m but juttery
	setDrivePIDSettings(0.15, 0.013, 7, 5000, 127);
	int numTicks = distanceToDriveTicks(distanceMeters);
	initializeDrivePID(numTicks, numTicks);
}

void initializeRotate(float angleDegrees) {
	setDrivePIDSettings(0.15, 0.02, 5, 5000, 127);
	int numTicks = angleDegrees/360.0 * 1760; // Measured that one rotation is around this many ticks
	initializeDrivePID(numTicks, -numTicks);

}

bool drivePidFinished() { return driveLPid.pidFinished && driveRPid.pidFinished; }

void driveLog() {
	datalogDataGroupStart();
	datalogAddValue(0, driveLPid.power);
	datalogAddValue(1, driveLPid.error);
	datalogAddValue(2, driveLPid.derivative);
	datalogAddValue(3, driveLPid.integral);

	datalogAddValue(4, driveRPid.power);
	datalogAddValue(5, driveRPid.error);
	datalogAddValue(6, driveRPid.derivative);
	datalogAddValue(7, driveRPid.integral);

	datalogDataGroupEnd();
}


bool primeLauncher() {
	// Call this in a while loop to make it run with parallel with other tasks. Returns true if launcher is primed
	if (launcherSensor()) {
		motor[launcher] = 0;
		return true; // Finished
	}
	motor[launcher] = LAUNCHER_AUTO_SPEED;
	return false; // Not yet finished
}

void untilDrivePIDFinishes(bool primeLauncherVar) {
	while(!drivePidFinished()) {
		runDrivePid();
		wait1Msec(MAIN_LOOP_DELAY);
		driveLog();
		if (primeLauncherVar) primeLauncher();

		string s;
		sprintf(s, "%d %d", driveLPid.error, driveRPid.error);
		clearLCDLine(1);
		displayLCDString(1, 0, s);
	}
}


void rotationTest() {
	wait1Msec(2000);
	int numTimes = 9;
	for (int i = 0; i < numTimes; i++) {
		initializeRotate(90/numTimes);
		untilDrivePIDFinishes(false);
		wait1Msec(50);
	}
	initializeRotate(-90);
	untilDrivePIDFinishes(false);
	wait1Msec(50);
}


void launchBall() {
	// Occurs in series
	if (launcherSensor()) {
		// Already primed
		while(launcherSensor()) {
			wait1Msec(MAIN_LOOP_DELAY);
			motor[launcher] = LAUNCHER_AUTO_SPEED;
		}
	} else {
		// Uses the launcherStruct infrastructure even though it was designed for user input
		bool prevState = launcherSensor();
		ubyte numTransitions = 0;
		while(numTransitions < 2) { // Once it goes from false->true->false, end it
		 	wait1Msec(MAIN_LOOP_DELAY);
		 	if (prevState != launcherSensor()) {
		 		prevState = !prevState; // Get new state
		 		numTransitions++;
		 	}
		 	motor[launcher] = LAUNCHER_AUTO_SPEED;
		}
	}
	motor[launcher] = 0; // End
}



void autoRedNear() {
	// Centered on red tile horizontally. Front wheels touching the jigsaw edge thing
	// Shoots to high flag, toggles low flag and then moves back
	initializeDriveStraight(0.4);
	untilDrivePIDFinishes(true);

	wait1Msec(200);
	initializeRotate(-3); // At the end, it rotates slightly for some reason.
	//untilDrivePIDFinishes(true);

	launchBall();

	initializeRotate(-4);
	motor[intake] = INTAKE_SPEED;

	initializeDriveStraight(-1.65);
	untilDrivePIDFinishes(false);

	wait1Msec(200);
	initializeDriveStraight(0.7);
	untilDrivePIDFinishes(false);

	initializeRotate(-84); // Over-rotates
	untilDrivePIDFinishes(false);
	motor[intake] = 0;

	SensorValue[claw] = true;

	initializeDriveStraight(0.28);
	untilDrivePIDFinishes(false);

	SensorValue[claw] = false;

}


void autoBlueNear() {
	// Scores high flag then low flag
	// Centered
	initializeDriveStraight(0.2);
	untilDrivePIDFinishes(true);

	initializeRotate(-13.5);
	untilDrivePIDFinishes(true);

	launchBall();
	motor[intake] = INTAKE_SPEED;

	initializeRotate(14);
	untilDrivePIDFinishes(false);

	initializeDriveStraight(-1.4);
	untilDrivePIDFinishes(false);

	initializeDriveStraight(0.65);
	untilDrivePIDFinishes(false);

	motor[intake] = 0;

	initializeRotate(100);
	untilDrivePIDFinishes(false);

	SensorValue[claw] = true;

	initializeDriveStraight(0.27);
	untilDrivePIDFinishes(false);

	SensorValue[claw] = false;
	//initializeDriveStraight(1.4);
	//untilDrivePIDFinishes(false);
}


void autoBlueFar()  {
	SensorValue[claw] = true;

	initializeDriveStraight(0.80);
	untilDrivePIDFinishes(false);

	initializeRotate(-270); // Rotate the other way to score the cap (remove ball from underneath it) while not getting in the way of climbing~~While driving forwards, it rotates a bit for some reason. Lower than 90 to compensate~~
	untilDrivePIDFinishes(false);

	SensorValue[claw] = false;
	resetPid(&armPid);
	setPidTarget(&armPid, 400);
	while (!armPid.pidFinished) {
		wait1Msec(MAIN_LOOP_DELAY);
		arm(runPid(&armPid, nMotorEncoder[armL]));
	}
	for (int i = 0; i < 2500/MAIN_LOOP_DELAY; i++) {
		drive(127, 127, false); // Max power
		arm(runPid(&armPid, nMotorEncoder[armL])); // Keep the arm up
		wait1Msec(MAIN_LOOP_DELAY);
	}
	initializeDriveStraight(0); // Stop (trying to remove momentum)
	untilDrivePIDFinishes(false);
}

void autoRedFar()  {
	// Climbs up to the alliance platform after rotating to scroe a cap (the one with the ball underneath)
	SensorValue[claw] = true;

	initializeDriveStraight(0.85);
	untilDrivePIDFinishes(false);

	initializeRotate(300); // Rotate the other way to score the cap (remove ball from underneath it) while not getting in the way of climbing~~While driving forwards, it rotates a bit for some reason. Lower than 90 to compensate~~
	untilDrivePIDFinishes(false);

	SensorValue[claw] = false;
	resetPid(&armPid);
	setPidTarget(&armPid, 400);
	while (!armPid.pidFinished) {
		wait1Msec(MAIN_LOOP_DELAY);
		arm(runPid(&armPid, nMotorEncoder[armL]));
	}
	for (int i = 0; i < 2500/MAIN_LOOP_DELAY; i++) {
		drive(127, 127, false); // Max power
		arm(runPid(&armPid, nMotorEncoder[armL])); // Keep the arm up
		wait1Msec(MAIN_LOOP_DELAY);
	}
	initializeDriveStraight(0); // Stop (trying to remove momentum)
	untilDrivePIDFinishes(false);

	//initializeRotate(-160);
	//untilDrivePIDFinishes(true);
	//launchBall();
	//initializeDriveStraight(1);
	//untilDrivePIDFinishes(false);
}

void autonomousWrapper() {
	switch(toggleAutonomousMode.state) {
		case 0: autoBlueNear(); break;
		case 1: autoBlueFar() ;	break;
		case 2: autoRedNear() ;	break;
		case 3:	autoRedFar()  ;	break;
	}
}

task autonomous()
{
	autonomousWrapper();
}




task usercontrol()
{
	lcdPrintAutonomousMode(); // Print the initial state. Didn't work when in pre_auton for some reason
	while (true)
	{
		// ### Random
		wait1Msec(MAIN_LOOP_DELAY);

		clearLCDLine(0);
		if (nImmediateBatteryLevel == 0 || SensorValue[powerExpanderBatterySensor] < 300) sprintf(line1, "CHECK BATTERY"); // Primary battery not plugged in/cortex off, or secondary battery or its status port not plugged in
		else sprintf(line1,"A%dL%dR%d", nMotorEncoder(armL), nMotorEncoder(driveMBL), nMotorEncoder(driveMR)); // Prints values for all IMEs. No spaces to try fit everything in one line
		displayLCDString(0,0,line1);

		if (nLCDButtons == 2) {
			wait1Msec(1000);
			autonomousWrapper(); // For when there is no field control. Start auto with ~~7L and 8R~~ (or with LCD middle button)
		}

		if (NToggleButtonSetter(&toggleAutonomousMode, nLCDButtons == 4)) {
			lcdPrintAutonomousMode(); // When button clicked, update display to reflect
		}

		// ### Drive
		toggleButtonSetter(&toggleDriveReversed, vexRT[BTN_TOGGLE_DRIVE_REVERSED]);
		toggleButtonSetter(&toggleDriveSensitivity, vexRT[BTN_TOGGLE_DRIVE_SENSITIVITY]);

		if (toggleDriveReversed.isTrue) drive(-vexRT[Ch2], -vexRT[Ch3], toggleDriveSensitivity.isTrue);
		else drive(vexRT[Ch3], vexRT[Ch2], toggleDriveSensitivity.isTrue);


		// ### Arm
		armLogic();

	    // ### Intake
		motor[intake] = (vexRT[BTN_INTAKE_IN] - vexRT[BTN_INTAKE_OUT]) * INTAKE_SPEED;

		// ### Pneumatics
		if (toggleButtonSetter(&toggleClawState, vexRT[BTN_TOGGLE_PNEUMATICS])) SensorValue[claw] = !SensorValue[claw]; //Switch value of claw

		// ### Launcher
		launcherLogic();
	}
}
