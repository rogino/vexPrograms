#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  quad,           sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port3,           armLeft,       tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port4,           puncher,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           armRight,      tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
/*
task main() {

	while(true) {
		writeDebugStreamLine("%d", getMotorEncoder(armLeft));
		wait1Msec(100);
	}

	slaveMotor(armRight, armLeft);
	setMotorTarget(armLeft, -100, 40, true);
	waitUntilMotorStop(armLeft);
	writeDebugStreamLine("Finished");*/
/*
	while(true) {
		motor[puncher] = vexRT[Ch1];
	}
}
*/


const float kP = 0.7;
const float kI = 0.01;
const float kD = 0.1;
const int sleepTime = 100;


int target = 696;
float integral = 0;
int prevError = 0;

task main() {
	slaveMotor(armRight, armLeft);
	nMotorEncoder[armLeft] = 0;

	while(true) {
		int error = target - nMotorEncoder[armLeft];
		integral += error;

		int deltaError = error - prevError;
		prevError = error;

		int power = error * kP + integral * kI + deltaError * kD;
		motor[armLeft] = power;


		writeDebugStreamLine("Motor: %d Sensor: %d Error: %d dt: %d Integral %d",power, nMotorEncoder[armLeft], error, deltaError, integral);
		wait1Msec(sleepTime);
	}
}
