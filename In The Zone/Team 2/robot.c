#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1, armBottom, sensorTouch)
#pragma config(Sensor, dgtl2, armTop, sensorTouch)
#pragma config(Sensor, dgtl9, l, sensorDigitalOut)
#pragma config(Sensor, dgtl10, r, sensorDigitalOut)
#pragma config(Sensor, I2C_1, RQuad, sensorQuadEncoderOnI2CPort, , AutoAssign )
#pragma config(Sensor, I2C_2, LQuad, sensorQuadEncoderOnI2CPort, , AutoAssign )
#pragma config(Motor, port1, BR, tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor, port2, armR, tmotorVex393_MC29, openLoop)
#pragma config(Motor, port3, armL, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor, port4, claw, tmotorServoStandard, openLoop)
#pragma config(Motor, port7, armR, tmotorVex393_MC29, openLoop)
#pragma config(Motor, port8, FL, tmotorVex393_MC29, openLoop)
#pragma config(Motor, port9, BL, tmotorVex393_MC29, openLoop)
#pragma config(Motor, port10, FR, tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton() {
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	//Masters: Back takes preference, left takes preference
	slaveMotor(FL, BL); //Set the value of BL to be synchronized to FL (BL is the master)
	slaveMotor(FR, BR);
	slaveMotor(armR, armL); //Same with arm
	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

//Global Variables
const int armSpeed = 80;
const int armSlowSpeed = 40;
const int clawSpeed = 100;
const int clawSlowSpeed = 40;
bool isTank = false;
bool previouslyPressed = false;
bool pneumaticsWasPressed = false;
bool isDown = false;

/*For the integrated encoder module*/
const float ticksPerRev[] = {627.2, 392, 261};
//Normal/Torque, Speed and Turbo


int exponential(int value) {
	return round((value * value)/127 * ((value > 0)?1:-1));
}


void drive(int left, int right) {
	motor[BL] = exponential(left);
	motor[BR] = exponential(right);
	// motor[BL] = motor[FL] = exponential(left);
	// motor[BR] = motor[FR] = exponential(right);
}


void setArmSpeed(int speed) {
	motor[armL] = speed;
	// motor[armL] = motor[armR] = speed;
}


void triggerPneumatics(bool dir) {
	SensorValue[l] = SensorValue[r] = dir?1:0;
}


void driveQuad(float rotationsLeft, float rotationsRight, float ticksPerRevolution, int maxSpeed) {
	//rotationsLeft, rotationsRight: number of rotations required. Can be -ve or +ve
	//ticksPerRevolution: the number of ticks of the integrated motor encoder before stopping
	//maxSpeed: the maximum speed of the motors allowed

	long ticksL = rotationsLeft * ticksPerRevolution;
	long ticksR = rotationsRight * ticksPerRevolution;

	moveMotorTarget(BL, ticksL, maxSpeed, false); //Do not maintain the position at the end
	moveMotorTarget(BR, ticksR, maxSpeed, false); //BL & FL, BR & FR should be linked

	while(!getMotorTargetCompleted(BL) && !getMotorTargetCompleted(BR)) {
		wait1Msec(10);
	}
}

void driveForwardsNMeters(float distanceMeters, float wheelDiameterInches, float ticksPerRevolution, int maxSpeed) {
	//Drives forwards a given distance
	float rotations = distanceMeters/(PI * wheelDiameterInches * 0.0254);
	driveQuad(rotations, rotations, ticksPerRevolution, maxSpeed);
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous() {
	// .....................................................................................
	// Insert user code here.
	// .....................................................................................
	/*
		In inches: theoretical distance is the hypotenuse of a tile (2 feet/24 inches) minus the depth of the robot.
		Thus, sqrt(2*24^2)-18
		In meters: (sqrt(2*24^2)-18)*0.0254=0.4049. But arm extends, so probably less than taht
	*/
	motor[claw] = -clawSpeed;
	wait1Msec(500);
	motor[claw] = -clawSlowSpeed;
	motor[armL] = 40;
	wait1Msec(800);
	motor[armL] = 20;
	driveForwardsNMeters(0.4, 4, ticksPerRev[0], 50);
	wait1Msec(300);

	motor[claw] = clawSpeed;
	wait1Msec(400);
	motor[claw] = 0;

}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol() {
	// User control code here, inside the loop

	while (true) {
		// This is the main execution loop for the user control program. Each time through the loop
		// your program should update motor + servo values based on feedback from the joysticks.

		// .....................................................................................
		// Insert user code here. This is where you use the joystick values to update your motors, etc.
		// .....................................................................................
		wait1Msec(1);

		if (isTank) {
			drive(vexRT[Ch3], vexRT[Ch2]);
		}
		else {
			drive(vexRT[Ch3] + vexRT[Ch1], vexRT[Ch3] - vexRT[Ch1]);
		}

		if (vexRT[Btn8D]) {
			if (!previouslyPressed) {
				//If was not previously pressed
				isTank = !isTank; //Change mode
			}
			previouslyPressed = true;
		}
		else {
			previouslyPressed = false;
		}

		//Arm
		if (vexRT[Btn5D] && vexRT[Btn5U]) {
			setArmSpeed(armSlowSpeed);
		}
		else if (vexRT[Btn5D] && !SensorValue[armBottom]) {
			setArmSpeed( - armSpeed);
		}
		else if (vexRT[Btn5U] && !SensorValue[armTop]) {
			setArmSpeed(armSpeed);
		}
		else {
			setArmSpeed(0);
		}

		//Claw
		if (vexRT[Btn6D] && vexRT[Btn6U]) {
			motor[claw] =  - clawSlowSpeed;
		}
		else if (vexRT[Btn6U]) {
			motor[claw] = clawSpeed;
		}
		else if (vexRT[Btn6D]) {
			motor[claw] =  - clawSpeed;
		}
		else {
			motor[claw] = 0;
		}
		if (!pneumaticsWasPressed && vexRT[Btn7D]) {
			pneumaticsWasPressed = true;
			isDown = !isDown;
			triggerPneumatics(isDown); //Switch on/offf
		}

		else if (!vexRT[Btn7D]) {
			pneumaticsWasPressed = false; //Switch pneumatics position only when pressed
		}
	}
}
