#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  armBottom,      sensorTouch)
#pragma config(Sensor, dgtl2,  armTop,         sensorTouch)
#pragma config(Sensor, dgtl9,  l,              sensorDigitalOut)
#pragma config(Sensor, dgtl10, r,              sensorDigitalOut)
#pragma config(Sensor, dgtl12, defaultDrive,   sensorDigitalIn)
#pragma config(Sensor, I2C_1,  RQuad,          sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  LQuad,          sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           FR,            tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           armR,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           armL,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           claw,          tmotorServoStandard, openLoop)
#pragma config(Motor,  port7,           push,          tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port8,           FL,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           BL,            tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port10,          BR,            tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!





//Global Variables
const int armSpeed = 80;
const int armSlowSpeed = 40;
const int clawSpeed = 100;
const int clawSlowSpeed = 40;
const int pushSpeed = 127;
bool isTank = SensorValue[defaultDrive]?false:true;
//If the jumper cable is plugged in, default is tank.

bool previouslyPressed = false;
bool pneumaticsWasPressed = false;
bool isDown = false;

/*For the integrated encoder module*/
const float ticksPerRev[] = {627.2, 392, 261};
//Normal/Torque, Speed and Turbo


int exponential(int value) {
	//input sqaured divided by 127 with a sign because reasons
	//And rounded because why not
	return round((value * value)/127 * ((value > 0)?1:-1));
}


void drive(int left, int right) {
	motor[BL] = exponential(left);
	motor[BR] = exponential(right);
	// motor[BL] = motor[FL] = exponential(left);
	// motor[BR] = motor[FR] = exponential(right);
}


void setArmSpeed(int speed) {
	motor[armL] = speed;
	// motor[armL] = motor[armR] = speed;
}


void triggerPneumatics(bool dir) {
	SensorValue[l] = SensorValue[r] = dir?1:0;
}

bool goalReached(bool direction, long goal, long current) {
	if (direction) {
		//If greater than
		return (current > goal);
	}
	else {
		return (current < goal);
	}
}

void driveQuad(float rotationsLeft, float rotationsRight, float ticksPerRevolution, int maxSpeed) {
	//rotationsLeft, rotationsRight: number of rotations required. Can be -ve or +ve
	//ticksPerRevolution: the number of ticks of the integrated motor encoder before stopping
	//maxSpeed: the maximum speed of the motors allowed
  //writeDebugStreamLine("%d", maxSpeed);
	nMotorEncoder(BR) = 0;
	nMotorEncoder(BL) = 0;
	long ticksL = rotationsLeft * ticksPerRevolution;
	long ticksR = rotationsRight * ticksPerRevolution;
	bool dirL = ticksL > 0;
	bool dirR = ticksR > 0;
	drive(maxSpeed, maxSpeed);
	while(true) {

		if (goalReached(dirL, ticksL, nMotorEncoder(BL)) && goalReached(dirR, ticksR, nMotorEncoder(BR))) {
			break;
		}
		else if (goalReached(dirL, ticksL, nMotorEncoder(BL))) {
			motor[BL] = 0;
		}
		else if (goalReached(dirR, ticksR, nMotorEncoder(BR))) {
			motor[BR] = 0;
		}
		wait1Msec(100);

		/*writeDebugStreamLine("right: %ld. Goal: %ld", nMotorEncoder(BR), ticksR);
		writeDebugStreamLine("left: %ld. Goal: %ld", nMotorEncoder(BL), ticksL);*/
	}
	/*writeDebugStreamLine("Left: %ld. Right %ld", ticksL, ticksR);
	moveMotorTarget(BL, ticksL, maxSpeed, false); //Do not maintain the position at the end
	moveMotorTarget(BR, ticksR, maxSpeed, false); //BL & FL, BR & FR should be linked

	while(!getMotorTargetCompleted(BL) && !getMotorTargetCompleted(BR)) {
		writeDebugStreamLine("MotorEncoderValue: %ld. Ticks Wanted: %ld", nMotorEncoder(BR), ticksR);
		wait1Msec(100);
	}*/
	drive(0,0);
}

void driveForwardsNMeters(float distanceMeters, float wheelDiameterInches, float ticksPerRevolution, int maxSpeed) {
	//Drives forwards a given distance
	float rotations = distanceMeters/(PI * wheelDiameterInches * 0.0254);
	//writeDebugStreamLine("Rotations: %f", rotations);
	driveQuad(rotations, rotations, ticksPerRevolution, maxSpeed);
}



/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton() {
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	//Masters: Back takes preference, left takes preference
	slaveMotor(FL, BL); //Set the value of BL to be synchronized to FL (BL is the master)
	slaveMotor(FR, BR);
	slaveMotor(armR, armL); //Same with arm

	//Left is master
	//Praise communism

	//driveForwardsNMeters(1.4, 4, ticksPerRev[0], 50);
	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...

	/*while(true) {
		wait10Msec(10);
		writeDebugStreamLine("right: %ld", nMotorEncoder(BR));
		writeDebugStreamLine("left: %ld", nMotorEncoder(BL));
	}*/
}





/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

void autoTest() {

	motor[claw] = -80;
	wait1Msec(1000);
	motor[claw] = -clawSlowSpeed;
	motor[armL] = 60;
	while(!SensorValue[armTop]) {
		wait1Msec(50);
	}

	motor[armL] = 20;
	driveForwardsNMeters(0.275, 4, ticksPerRev[1], 70);
	wait1Msec(800);

	motor[claw] = clawSpeed;
	wait1Msec(400);
	motor[claw] = 0;
}

task autonomous() {

	autoTest();
	// .....................................................................................
	// Insert user code here.
	// .....................................................................................
	/*
		In inches: theoretical distance is the hypotenuse of a tile (2 feet/24 inches) minus the depth of the robot.
		Thus, sqrt(2*24^2)-18
		In meters: (sqrt(2*24^2)-18)*0.0254=0.4049. But arm extends, so probably less than taht
	*/

	//What a nerd


}
/*
/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////
*/

task usercontrol() {

	// User control code here, inside the loop
	//autoTest();
	while (true) {
		// This is the main execution loop for the user control program. Each time through the loop
		// your program should update motor + servo values based on feedback from the joysticks.

		// .....................................................................................
		// Insert user code here. This is where you use the joystick values to update your motors, etc.
		// .....................................................................................
		wait1Msec(10);


		if (vexRT[Btn8L]) autoTest();

		if (isTank) {
			drive(vexRT[Ch3], vexRT[Ch2]);
		}
		else {
			drive(vexRT[Ch3] + vexRT[Ch1], vexRT[Ch3] - vexRT[Ch1]);
			//drive(-vexRT[AccelY] + vexRT[AccelX], -vexRT[AccelY] - vexRT[AccelX]);
		}

		if (vexRT[Btn8U]) {
			if (!previouslyPressed) {
				//If was not previously pressed
				isTank = !isTank; //Change mode
			}
			previouslyPressed = true;
		}
		else {
			previouslyPressed = false;
		}

		//Arm

		//Cancer 101

		//setArmSpeed(vexRT[AccelY]);

		if (vexRT[Btn5D] && vexRT[Btn5U]) {
			setArmSpeed(armSlowSpeed);
		}
		else if (vexRT[Btn5D] && !SensorValue[armBottom]) {
			setArmSpeed( - armSpeed);
		}
		else if (vexRT[Btn5U] && !SensorValue[armTop]) {
			setArmSpeed(armSpeed);
		}
		else {
			setArmSpeed(0);
		}


		//Claw
		if (vexRT[Btn6D] && vexRT[Btn6U]) {
			motor[claw] =  - clawSlowSpeed;
		}
		else if (vexRT[Btn6U]) {
			motor[claw] = clawSpeed;
		}
		else if (vexRT[Btn6D]) {
			motor[claw] =  - clawSpeed;
		}
		else {
			motor[claw] = 0;
		}
		if (!pneumaticsWasPressed && vexRT[Btn7D]) {
			pneumaticsWasPressed = true;
			isDown = !isDown;
			triggerPneumatics(isDown); //Switch on/offf
		}

		else if (!vexRT[Btn7D]) {
			pneumaticsWasPressed = false; //Switch pneumatics position only when pressed
		}

		//Pusher
		if (vexRT[Btn8R]) {
			motor[push] = pushSpeed;
		}
		else if (vexRT[Btn8D]) {
			motor[push] = -pushSpeed;
		}
		else {
			motor[push] = 0;
		}
	}
}
