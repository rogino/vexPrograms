#pragma config(Sensor, in1,    shoulderPot,    sensorPotentiometer)
#pragma config(Sensor, in2,    wristPot,       sensorPotentiometer)
#pragma config(Motor,  port2,           driveR,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           driveL,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           armR,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           armL,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           wristR,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           wristL,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           driveS,        tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
int quadratic(int input) {
    float answer;
	answer = (input * input);
	answer = answer * -0.00000710443;
	answer = answer + 0.0609411 * input;
	answer = answer - 1.28553;
	//-0.00000710443x^2 + 0.0609411x - 1.28553
	if (answer<0) {
	    answer = 0;
	    
	} else if (answer > 127) {
	    answer = 127;
	    
	}
	int output = (int) answer;
	//printf("\n%d\n", output);
	return output;
}

task main() {
	int targetAngle = -15;//Two variables whose value should not be reset everytime in the loop
	int count = 0;
	int howOftenToRunArmStabilizationLoop = 9;
	while (true) {
		motor[driveR] = vexRT[Ch3] + (-vexRT[Ch1]);
		motor[driveL] = vexRT[Ch3] + vexRT[Ch1];
		motor[driveS] = vexRT[Ch4];

		if (vexRT[Btn6D]) {
			motor[wristR] = 127;
			motor[wristL] = 127;
		}
		else if (vexRT[Btn5D]) {
			motor[wristR] = -127;
			motor[wristL] = -127;
		}
		else {
			motor[wristR] = 0;
			motor[wristL] = 0;
		}

		/*The following code tries to balance the arm to stay level
		It, once manual control is off (no buttons controlling arm are pressed):
		1. It saves the current angle using the potentiometer
		2. Checks if the arm is below the potentiometer value. If so, increase motor speed by 1
		3. Does the opposite if going up
		4. Does this until a button (for controlling arm) is pressed
		*/
		count++;//Count can go between 0 and 9
		if (count >=howOftenToRunArmStabilizationLoop + 1) {
			count = 0;
		}
		//count allows loop to only run 1/10th of loops to decrease sensitivity of angle correction
		if (count == howOftenToRunArmStabilizationLoop && (!(vexRT[Btn6U] || vexRT[Btn5U]))) { //If 9 loops have gone, then:
			
			if (targetAngle == -15) {//a value that cannot be reached unless by manual setting
				targetAngle = SensorValue[shoulderPot];//Sets the target angle
			}//It runs once when the buttons have been released, setting that as the angle to aim for

			else if (targetAngle > SensorValue[shoulderPot]) {//If the potentiometer value is smaller than the target angle,
				motor[armR]++;
				motor[armL]++; //Increase the speed of the motors by 1
			}

			else if (targetAngle < SensorValue[shoulderPot]) {//If it is bigger (going up)
				motor[armR]--;
				motor[armL]--; //Decrease the speed of the motors by 1
			}
		}



		else if (vexRT[Btn6U] || vexRT[Btn5U]) {//If a button is pressed
			targetAngle = -15;//Reset angle

			if (vexRT[Btn6U]) {//If button to go up pressed
				motor[armR] = 100;//blabla
				motor[armL] = 100;//Setting speed to go up	
			}

			else if (vexRT[Btn5U]) {
				motor[armR] = -43;//Why the hell is it -43?
				motor[armL] = -43;
			}
		}


	}//While true infinite loop brace		
}//Task main brace
